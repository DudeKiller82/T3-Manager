This is make.info, produced by makeinfo version 4.8 from make.texi.

   This file documents the GNU `make' utility, which determines
automatically which pieces of a large program need to be recompiled,
and issues the commands to recompile them.

   This is Edition 0.70, last updated 1 April 2006, of `The GNU Make
Manual', for GNU `make' version 3.81.

   Copyright (C) 1988, 1989, 1990, 1991, 1992, 1993, 1994, 1995, 1996,
1997, 1998, 1999, 2000, 2002, 2003, 2004, 2005, 2006 Free Software
Foundation, Inc.

     Permission is granted to copy, distribute and/or modify this
     document under the terms of the GNU Free Documentation License,
     Version 1.2 or any later version published by the Free Software
     Foundation; with no Invariant Sections, with the Front-Cover Texts
     being "A GNU Manual," and with the Back-Cover Texts as in (a)
     below.  A copy of the license is included in the section entitled
     "GNU Free Documentation License."

     (a) The FSF's Back-Cover Text is: "You have freedom to copy and
     modify this GNU Manual, like GNU software.  Copies published by
     the Free Software Foundation raise funds for GNU development."

INFO-DIR-SECTION GNU Packages
START-INFO-DIR-ENTRY
* Make: (make).            Remake files automatically.
END-INFO-DIR-ENTRY


File: make.info,  Node: Top,  Next: Overview,  Prev: (dir),  Up: (dir)

GNU `make'
**********

This file documents the GNU `make' utility, which determines
automatically which pieces of a large program need to be recompiled,
and issues the commands to recompile them.

   This is Edition 0.70, last updated 1 April 2006, of `The GNU Make
Manual', for GNU `make' version 3.81.

   Copyright (C) 1988, 1989, 1990, 1991, 1992, 1993, 1994, 1995, 1996,
1997, 1998, 1999, 2000, 2002, 2003, 2004, 2005, 2006 Free Software
Foundation, Inc.

     Permission is granted to copy, distribute and/or modify this
     document under the terms of the GNU Free Documentation License,
     Version 1.2 or any later version published by the Free Software
     Foundation; with no Invariant Sections, with the Front-Cover Texts
     being "A GNU Manual," and with the Back-Cover Texts as in (a)
     below.  A copy of the license is included in the section entitled
     "GNU Free Documentation License."

     (a) The FSF's Back-Cover Text is: "You have freedom to copy and
     modify this GNU Manual, like GNU software.  Copies published by
     the Free Software Foundation raise funds for GNU development."

* Menu:

* Overview::                    Overview of `make'.
* Introduction::                An introduction to `make'.
* Makefiles::                   Makefiles tell `make' what to do.
* Rules::                       Rules describe when a file must be remade.
* Commands::                    Commands say how to remake a file.
* Using Variables::             You can use variables to avoid repetition.
* Conditionals::                Use or ignore parts of the makefile based
                                  on the values of variables.
* Functions::                   Many powerful ways to manipulate text.
* Invoking make: Running.       How to invoke `make' on the command line.
* Implicit Rules::              Use implicit rules to treat many files alike,
                                  based on their file names.
* Archives::                    How `make' can update library archives.
* Features::                    Features GNU `make' has over other `make's.
* Missing::                     What GNU `make' lacks from other `make's.
* Makefile Conventions::        Conventions for writing makefiles for
                                  GNU programs.
* Quick Reference::             A quick reference for experienced users.
* Error Messages::              A list of common errors generated by `make'.
* Complex Makefile::            A real example of a straightforward,
                                  but nontrivial, makefile.

* GNU Free Documentation License::  License for copying this manual
* Concept Index::               Index of Concepts
* Name Index::                  Index of Functions, Variables, & Directives

 --- The Detailed Node Listing ---

Overview of `make'

* Preparing::                   Preparing and Running Make
* Reading::                     On Reading this Text
* Bugs::                        Problems and Bugs

An Introduction to Makefiles

* Rule Introduction::           What a rule looks like.
* Simple Makefile::             A Simple Makefile
* How Make Works::              How `make' Processes This Makefile
* Variables Simplify::          Variables Make Makefiles Simpler
* make Deduces::                Letting `make' Deduce the Commands
* Combine By Prerequisite::     Another Style of Makefile
* Cleanup::                     Rules for Cleaning the Directory

Writing Makefiles

* Makefile Contents::           What makefiles contain.
* Makefile Names::              How to name your makefile.
* Include::                     How one makefile can use another makefile.
* MAKEFILES Variable::          The environment can specify extra makefiles.
* MAKEFILE_LIST Variable::      Discover which makefiles have been read.
* Special Variables::           Other special variables.
* Remaking Makefiles::          How makefiles get remade.
* Overriding Makefiles::        How to override part of one makefile
                                  with another makefile.
* Reading Makefiles::           How makefiles are parsed.
* Secondary Expansion::         How and when secondary expansion is performed.

Writing Rules

* Rule Example::                An example explained.
* Rule Syntax::                 General syntax explained.
* Prerequisite Types::          There are two types of prerequisites.
* Wildcards::                   Using wildcard characters such as `*'.
* Directory Search::            Searching other directories for source files.
* Phony Targets::               Using a target that is not a real file's name.
* Force Targets::               You can use a target without commands
                                  or prerequisites to mark other targets
                                  as phony.
* Empty Targets::               When only the date matters and the
                                  files are empty.
* Special Targets::             Targets with special built-in meanings.
* Multiple Targets::            When to make use of several targets in a rule.
* Multiple Rules::              How to use several rules with the same target.
* Static Pattern::              Static pattern rules apply to multiple targets
                                  and can vary the prerequisites according to
                                  the target name.
* Double-Colon::                How to use a special kind of rule to allow
                                  several independent rules for one target.
* Automatic Prerequisites::     How to automatically generate rules giving
                                  prerequisites from source files themselves.

Using Wildcard Characters in File Names

* Wildcard Examples::           Several examples
* Wildcard Pitfall::            Problems to avoid.
* Wildcard Function::           How to cause wildcard expansion where
                                  it does not normally take place.

Searching Directories for Prerequisites

* General Search::              Specifying a search path that applies
                                  to every prerequisite.
* Selective Search::            Specifying a search path
                                  for a specified class of names.
* Search Algorithm::            When and how search paths are applied.
* Commands/Search::             How to write shell commands that work together
                                  with search paths.
* Implicit/Search::             How search paths affect implicit rules.
* Libraries/Search::            Directory search for link libraries.

Static Pattern Rules

* Static Usage::                The syntax of static pattern rules.
* Static versus Implicit::      When are they better than implicit rules?

Writing the Commands in Rules

* Command Syntax::              Command syntax features and pitfalls.
* Echoing::                     How to control when commands are echoed.
* Execution::                   How commands are executed.
* Parallel::                    How commands can be executed in parallel.
* Errors::                      What happens after a command execution error.
* Interrupts::                  What happens when a command is interrupted.
* Recursion::                   Invoking `make' from makefiles.
* Sequences::                   Defining canned sequences of commands.
* Empty Commands::              Defining useful, do-nothing commands.

Command Syntax

* Splitting Lines::             Breaking long command lines for readability.
* Variables in Commands::       Using `make' variables in commands.

Command Execution

* Choosing the Shell::          How `make' chooses the shell used
                                  to run commands.

Recursive Use of `make'

* MAKE Variable::               The special effects of using `$(MAKE)'.
* Variables/Recursion::         How to communicate variables to a sub-`make'.
* Options/Recursion::           How to communicate options to a sub-`make'.
* -w Option::                   How the `-w' or `--print-directory' option
                                  helps debug use of recursive `make' commands.

How to Use Variables

* Reference::                   How to use the value of a variable.
* Flavors::                     Variables come in two flavors.
* Advanced::                    Advanced features for referencing a variable.
* Values::                      All the ways variables get their values.
* Setting::                     How to set a variable in the makefile.
* Appending::                   How to append more text to the old value
                                  of a variable.
* Override Directive::          How to set a variable in the makefile even if
                                  the user has set it with a command argument.
* Defining::                    An alternate way to set a variable
                                  to a verbatim string.
* Environment::                 Variable values can come from the environment.
* Target-specific::             Variable values can be defined on a per-target
                                  basis.
* Pattern-specific::            Target-specific variable values can be applied
                                  to a group of targets that match a pattern.

Advanced Features for Reference to Variables

* Substitution Refs::           Referencing a variable with
                                  substitutions on the value.
* Computed Names::              Computing the name of the variable to refer to.

Conditional Parts of Makefiles

* Conditional Example::         Example of a conditional
* Conditional Syntax::          The syntax of conditionals.
* Testing Flags::               Conditionals that test flags.

Functions for Transforming Text

* Syntax of Functions::         How to write a function call.
* Text Functions::              General-purpose text manipulation functions.
* File Name Functions::         Functions for manipulating file names.
* Conditional Functions::       Functions that implement conditions.
* Foreach Function::            Repeat some text with controlled variation.
* Call Function::               Expand a user-defined function.
* Value Function::              Return the un-expanded value of a variable.
* Eval Function::               Evaluate the arguments as makefile syntax.
* Origin Function::             Find where a variable got its value.
* Flavor Function::             Find out the flavor of a variable.
* Shell Function::              Substitute the output of a shell command.
* Make Control Functions::      Functions that control how make runs.

How to Run `make'

* Makefile Arguments::          How to specify which makefile to use.
* Goals::                       How to use goal arguments to specify which
                                  parts of the makefile to use.
* Instead of Execution::        How to use mode flags to specify what
                                  kind of thing to do with the commands
                                  in the makefile other than simply
                                  execute them.
* Avoiding Compilation::        How to avoid recompiling certain files.
* Overriding::                  How to override a variable to specify
                                  an alternate compiler and other things.
* Testing::                     How to proceed past some errors, to
                                  test compilation.
* Options Summary::             Summary of Options

Using Implicit Rules

* Using Implicit::              How to use an existing implicit rule
                                  to get the commands for updating a file.
* Catalogue of Rules::          A list of built-in implicit rules.
* Implicit Variables::          How to change what predefined rules do.
* Chained Rules::               How to use a chain of implicit rules.
* Pattern Rules::               How to define new implicit rules.
* Last Resort::                 How to define commands for rules which
                                  cannot find any.
* Suffix Rules::                The old-fashioned style of implicit rule.
* Implicit Rule Search::        The precise algorithm for applying
                                  implicit rules.

Defining and Redefining Pattern Rules

* Pattern Intro::               An introduction to pattern rules.
* Pattern Examples::            Examples of pattern rules.
* Automatic Variables::         How to use automatic variables in the
                                  commands of implicit rules.
* Pattern Match::               How patterns match.
* Match-Anything Rules::        Precautions you should take prior to
                                  defining rules that can match any
                                  target file whatever.
* Canceling Rules::             How to override or cancel built-in rules.

Using `make' to Update Archive Files

* Archive Members::             Archive members as targets.
* Archive Update::              The implicit rule for archive member targets.
* Archive Pitfalls::            Dangers to watch out for when using archives.
* Archive Suffix Rules::        You can write a special kind of suffix rule
                                  for updating archives.

Implicit Rule for Archive Member Targets

* Archive Symbols::             How to update archive symbol directories.


File: make.info,  Node: Overview,  Next: Introduction,  Prev: Top,  Up: Top

1 Overview of `make'
********************

The `make' utility automatically determines which pieces of a large
program need to be recompiled, and issues commands to recompile them.
This manual describes GNU `make', which was implemented by Richard
Stallman and Roland McGrath.  Development since Version 3.76 has been
handled by Paul D. Smith.

   GNU `make' conforms to section 6.2 of `IEEE Standard 1003.2-1992'
(POSIX.2).  

   Our examples show C programs, since they are most common, but you
can use `make' with any programming language whose compiler can be run
with a shell command.  Indeed, `make' is not limited to programs.  You
can use it to describe any task where some files must be updated
automatically from others whenever the others change.

* Menu:

* Preparing::                   Preparing and Running Make
* Reading::                     On Reading this Text
* Bugs::                        Problems and Bugs


File: make.info,  Node: Preparing,  Next: Reading,  Prev: Overview,  Up: Overview

Preparing and Running Make
==========================

   To prepare to use `make', you must write a file called the
"makefile" that describes the relationships among files in your program
and provides commands for updating each file.  In a program, typically,
the executable file is updated from object files, which are in turn
made by compiling source files.

   Once a suitable makefile exists, each time you change some source
files, this simple shell command:

     make

suffices to perform all necessary recompilations.  The `make' program
uses the makefile data base and the last-modification times of the
files to decide which of the files need to be updated.  For each of
those files, it issues the commands recorded in the data base.

   You can provide command line arguments to `make' to control which
files should be recompiled, or how.  *Note How to Run `make': Running.


File: make.info,  Node: Reading,  Next: Bugs,  Prev: Preparing,  Up: Overview

1.1 How to Read This Manual
===========================

If you are new to `make', or are looking for a general introduction,
read the first few sections of each chapter, skipping the later
sections.  In each chapter, the first few sections contain introductory
or general information and the later sections contain specialized or
technical information.  The exception is the second chapter, *Note An
Introduction to Makefiles: Introduction, all of which is introductory.

   If you are familiar with other `make' programs, see *Note Features
of GNU `make': Features, which lists the enhancements GNU `make' has,
and *Note Incompatibilities and Missing Features: Missing, which
explains the few things GNU `make' lacks that others have.

   For a quick summary, see *Note Options Summary::, *Note Quick
Reference::, and *Note Special Targets::.


File: make.info,  Node: Bugs,  Prev: Reading,  Up: Overview

1.2 Problems and Bugs
=====================

If you have problems with GNU `make' or think you've found a bug,
please report it to the developers; we cannot promise to do anything but
we might well want to fix it.

   Before reporting a bug, make sure you've actually found a real bug.
Carefully reread the documentation and see if it really says you can do
what you're trying to do.  If it's not clear whether you should be able
to do something or not, report that too; it's a bug in the
documentation!

   Before reporting a bug or trying to fix it yourself, try to isolate
it to the smallest possible makefile that reproduces the problem.  Then
send us the makefile and the exact results `make' gave you, including
any error or warning messages.  Please don't paraphrase these messages:
it's best to cut and paste them into your report.  When generating this
small makefile, be sure to not use any non-free or unusual tools in
your commands: you can almost always emulate what such a tool would do
with simple shell commands.  Finally, be sure to explain what you
expected to occur; this will help us decide whether the problem was
really in the documentation.

   Once you have a precise problem you can report it in one of two ways.
Either send electronic mail to:

         bug-make@gnu.org

or use our Web-based project management tool, at:

         http://savannah.gnu.org/projects/make/

In addition to the information above, please be careful to include the
version number of `make' you are using.  You can get this information
with the command `make --version'.  Be sure also to include the type of
machine and operating system you are using.  One way to obtain this
information is by looking at the final lines of output from the command
`make --help'.


File: make.info,  Node: Introduction,  Next: Makefiles,  Prev: Overview,  Up: Top

2 An Introduction to Makefiles
******************************

You need a file called a "makefile" to tell `make' what to do.  Most
often, the makefile tells `make' how to compile and link a program.  

   In this chapter, we will discuss a simple makefile that describes
how to compile and link a text editor which consists of eight C source
files and three header files.  The makefile can also tell `make' how to
run miscellaneous commands when explicitly asked (for example, to remove
certain files as a clean-up operation).  To see a more complex example
of a makefile, see *Note Complex Makefile::.

   When `make' recompiles the editor, each changed C source file must
be recompiled.  If a header file has changed, each C source file that
includes the header file must be recompiled to be safe.  Each
compilation produces an object file corresponding to the source file.
Finally, if any source file has been recompiled, all the object files,
whether newly made or saved from previous compilations, must be linked
together to produce the new executable editor.  

* Menu:

* Rule Introduction::           What a rule looks like.
* Simple Makefile::             A Simple Makefile
* How Make Works::              How `make' Processes This Makefile
* Variables Simplify::          Variables Make Makefiles Simpler
* make Deduces::                Letting `make' Deduce the Commands
* Combine By Prerequisite::     Another Style of Makefile
* Cleanup::                     Rules for Cleaning the Directory


File: make.info,  Node: Rule Introduction,  Next: Simple Makefile,  Prev: Introduction,  Up: Introduction

2.1 What a Rule Looks Like
==========================

A simple makefile consists of "rules" with the following shape:

     TARGET ... : PREREQUISITES ...
             COMMAND
             ...
             ...

   A "target" is usually the name of a file that is generated by a
program; examples of targets are executable or object files.  A target
can also be the name of an action to carry out, such as `clean' (*note
Phony Targets::).

   A "prerequisite" is a file that is used as input to create the
target.  A target often depends on several files.

   A "command" is an action that `make' carries out.  A rule may have
more than one command, each on its own line.  *Please note:* you need
to put a tab character at the beginning of every command line!  This is
an obscurity that catches the unwary.

   Usually a command is in a rule with prerequisites and serves to
create a target file if any of the prerequisites change.  However, the
rule that specifies commands for the target need not have
prerequisites.  For example, the rule containing the delete command
associated with the target `clean' does not have prerequisites.

   A "rule", then, explains how and when to remake certain files which
are the targets of the particular rule.  `make' carries out the
commands on the prerequisites to create or update the target.  A rule
can also explain how and when to carry out an action.  *Note Writing
Rules: Rules.

   A makefile may contain other text besides rules, but a simple
makefile need only contain rules.  Rules may look somewhat more
complicated than shown in this template, but all fit the pattern more
or less.


File: make.info,  Node: Simple Makefile,  Next: How Make Works,  Prev: Rule Introduction,  Up: Introduction

2.2 A Simple Makefile
=====================

Here is a straightforward makefile that describes the way an executable
file called `edit' depends on eight object files which, in turn, depend
on eight C source and three header files.

   In this example, all the C files include `defs.h', but only those
defining editing commands include `command.h', and only low level files
that change the editor buffer include `buffer.h'.

     edit : main.o kbd.o command.o display.o \
            insert.o search.o files.o utils.o
             cc -o edit main.o kbd.o command.o display.o \
                        insert.o search.o files.o utils.o

     main.o : main.c defs.h
             cc -c main.c
     kbd.o : kbd.c defs.h command.h
             cc -c kbd.c
     command.o : command.c defs.h command.h
             cc -c command.c
     display.o : display.c defs.h buffer.h
             cc -c display.c
     insert.o : insert.c defs.h buffer.h
             cc -c insert.c
     search.o : search.c defs.h buffer.h
             cc -c search.c
     files.o : files.c defs.h buffer.h command.h
             cc -c files.c
     utils.o : utils.c defs.h
             cc -c utils.c
     clean :
             rm edit main.o kbd.o command.o display.o \
                insert.o search.o files.o utils.o

We split each long line into two lines using backslash-newline; this is
like using one long line, but is easier to read.  

   To use this makefile to create the executable file called `edit',
type:

     make

   To use this makefile to delete the executable file and all the object
files from the directory, type:

     make clean

   In the example makefile, the targets include the executable file
`edit', and the object files `main.o' and `kbd.o'.  The prerequisites
are files such as `main.c' and `defs.h'.  In fact, each `.o' file is
both a target and a prerequisite.  Commands include `cc -c main.c' and
`cc -c kbd.c'.

   When a target is a file, it needs to be recompiled or relinked if any
of its prerequisites change.  In addition, any prerequisites that are
themselves automatically generated should be updated first.  In this
example, `edit' depends on each of the eight object files; the object
file `main.o' depends on the source file `main.c' and on the header
file `defs.h'.

   A shell command follows each line that contains a target and
prerequisites.  These shell commands say how to update the target file.
A tab character must come at the beginning of every command line to
distinguish command lines from other lines in the makefile.  (Bear in
mind that `make' does not know anything about how the commands work.
It is up to you to supply commands that will update the target file
properly.  All `make' does is execute the commands in the rule you have
specified when the target file needs to be updated.)  

   The target `clean' is not a file, but merely the name of an action.
Since you normally do not want to carry out the actions in this rule,
`clean' is not a prerequisite of any other rule.  Consequently, `make'
never does anything with it unless you tell it specifically.  Note that
this rule not only is not a prerequisite, it also does not have any
prerequisites, so the only purpose of the rule is to run the specified
commands.  Targets that do not refer to files but are just actions are
called "phony targets".  *Note Phony Targets::, for information about
this kind of target.  *Note Errors in Commands: Errors, to see how to
cause `make' to ignore errors from `rm' or any other command.  


File: make.info,  Node: How Make Works,  Next: Variables Simplify,  Prev: Simple Makefile,  Up: Introduction

2.3 How `make' Processes a Makefile
===================================

By default, `make' starts with the first target (not targets whose
names start with `.').  This is called the "default goal".  ("Goals"
are the targets that `make' strives ultimately to update.    You can
override this behavior using the command line (*note Arguments to
Specify the Goals: Goals.) or with the `.DEFAULT_GOAL' special variable
(*note Other Special Variables: Special Variables.).  

   In the simple example of the previous section, the default goal is to
update the executable program `edit'; therefore, we put that rule first.

   Thus, when you give the command:

     make

`make' reads the makefile in the current directory and begins by
processing the first rule.  In the example, this rule is for relinking
`edit'; but before `make' can fully process this rule, it must process
the rules for the files that `edit' depends on, which in this case are
the object files.  Each of these files is processed according to its
own rule.  These rules say to update each `.o' file by compiling its
source file.  The recompilation must be done if the source file, or any
of the header files named as prerequisites, is more recent than the
object file, or if the object file does not exist.

   The other rules are processed because their targets appear as
prerequisites of the goal.  If some other rule is not depended on by the
goal (or anything it depends on, etc.), that rule is not processed,
unless you tell `make' to do so (with a command such as `make clean').

   Before recompiling an object file, `make' considers updating its
prerequisites, the source file and header files.  This makefile does not
specify anything to be done for them--the `.c' and `.h' files are not
the targets of any rules--so `make' does nothing for these files.  But
`make' would update automatically generated C programs, such as those
made by Bison or Yacc, by their own rules at this time.

   After recompiling whichever object files need it, `make' decides
whether to relink `edit'.  This must be done if the file `edit' does
not exist, or if any of the object files are newer than it.  If an
object file was just recompiled, it is now newer than `edit', so `edit'
is relinked.  

   Thus, if we change the file `insert.c' and run `make', `make' will
compile that file to update `insert.o', and then link `edit'.  If we
change the file `command.h' and run `make', `make' will recompile the
object files `kbd.o', `command.o' and `files.o' and then link the file
`edit'.


File: make.info,  Node: Variables Simplify,  Next: make Deduces,  Prev: How Make Works,  Up: Introduction

2.4 Variables Make Makefiles Simpler
====================================

In our example, we had to list all the object files twice in the rule
for `edit' (repeated here):

     edit : main.o kbd.o command.o display.o \
                   insert.o search.o files.o utils.o
             cc -o edit main.o kbd.o command.o display.o \
                        insert.o search.o files.o utils.o

   Such duplication is error-prone; if a new object file is added to the
system, we might add it to one list and forget the other.  We can
eliminate the risk and simplify the makefile by using a variable.
"Variables" allow a text string to be defined once and substituted in
multiple places later (*note How to Use Variables: Using Variables.).

   It is standard practice for every makefile to have a variable named
`objects', `OBJECTS', `objs', `OBJS', `obj', or `OBJ' which is a list
of all object file names.  We would define such a variable `objects'
with a line like this in the makefile:

     objects = main.o kbd.o command.o display.o \
               insert.o search.o files.o utils.o

Then, each place we want to put a list of the object file names, we can
substitute the variable's value by writing `$(objects)' (*note How to
Use Variables: Using Variables.).

   Here is how the complete simple makefile looks when you use a
variable for the object files:

     objects = main.o kbd.o command.o display.o \
               insert.o search.o files.o utils.o

     edit : $(objects)
             cc -o edit $(objects)
     main.o : main.c defs.h
             cc -c main.c
     kbd.o : kbd.c defs.h command.h
             cc -c kbd.c
     command.o : command.c defs.h command.h
             cc -c command.c
     display.o : display.c defs.h buffer.h
             cc -c display.c
     insert.o : insert.c defs.h buffer.h
             cc -c insert.c
     search.o : search.c defs.h buffer.h
             cc -c search.c
     files.o : files.c defs.h buffer.h command.h
             cc -c files.c
     utils.o : utils.c defs.h
             cc -c utils.c
     clean :
             rm edit $(objects)


File: make.info,  Node: make Deduces,  Next: Combine By Prerequisite,  Prev: Variables Simplify,  Up: Introduction

2.5 Letting `make' Deduce the Commands
======================================

It is not necessary to spell out the commands for compiling the
individual C source files, because `make' can figure them out: it has an
"implicit rule" for updating a `.o' file from a correspondingly named
`.c' file using a `cc -c' command.  For example, it will use the
command `cc -c main.c -o main.o' to compile `main.c' into `main.o'.  We
can therefore omit the commands from the rules for the object files.
*Note Using Implicit Rules: Implicit Rules.

   When a `.c' file is used automatically in this way, it is also
automatically added to the list of prerequisites.  We can therefore omit
the `.c' files from the prerequisites, provided we omit the commands.

   Here is the entire example, with both of these changes, and a
variable `objects' as suggested above:

     objects = main.o kbd.o command.o display.o \
               insert.o search.o files.o utils.o

     edit : $(objects)
             cc -o edit $(objects)

     main.o : defs.h
     kbd.o : defs.h command.h
     command.o : defs.h command.h
     display.o : defs.h buffer.h
     insert.o : defs.h buffer.h
     search.o : defs.h buffer.h
     files.o : defs.h buffer.h command.h
     utils.o : defs.h

     .PHONY : clean
     clean :
             rm edit $(objects)

This is how we would write the makefile in actual practice.  (The
complications associated with `clean' are described elsewhere.  See
*Note Phony Targets::, and *Note Errors in Commands: Errors.)

   Because implicit rules are so convenient, they are important.  You
will see them used frequently.


File: make.info,  Node: Combine By Prerequisite,  Next: Cleanup,  Prev: make Deduces,  Up: Introduction

2.6 Another Style of Makefile
=============================

When the objects of a makefile are created only by implicit rules, an
alternative style of makefile is possible.  In this style of makefile,
you group entries by their prerequisites instead of by their targets.
Here is what one looks like:

     objects = main.o kbd.o command.o display.o \
               insert.o search.o files.o utils.o

     edit : $(objects)
             cc -o edit $(objects)

     $(objects) : defs.h
     kbd.o command.o files.o : command.h
     display.o insert.o search.o files.o : buffer.h

Here `defs.h' is given as a prerequisite of all the object files;
`command.h' and `buffer.h' are prerequisites of the specific object
files listed for them.

   Whether this is better is a matter of taste: it is more compact, but
some people dislike it because they find it clearer to put all the
information about each target in one place.


File: make.info,  Node: Cleanup,  Prev: Combine By Prerequisite,  Up: Introduction

2.7 Rules for Cleaning the Directory
====================================

Compiling a program is not the only thing you might want to write rules
for.  Makefiles commonly tell how to do a few other things besides
compiling a program: for example, how to delete all the object files
and executables so that the directory is `clean'.

   Here is how we could write a `make' rule for cleaning our example
editor:

     clean:
             rm edit $(objects)

   In practice, we might want to write the rule in a somewhat more
complicated manner to handle unanticipated situations.  We would do
this:

     .PHONY : clean
     clean :
             -rm edit $(objects)

This prevents `make' from getting confused by an actual file called
`clean' and causes it to continue in spite of errors from `rm'.  (See
*Note Phony Targets::, and *Note Errors in Commands: Errors.)

A rule such as this should not be placed at the beginning of the
makefile, because we do not want it to run by default!  Thus, in the
example makefile, we want the rule for `edit', which recompiles the
editor, to remain the default goal.

   Since `clean' is not a prerequisite of `edit', this rule will not
run at all if we give the command `make' with no arguments.  In order
to make the rule run, we have to type `make clean'.  *Note How to Run
`make': Running.


File: make.info,  Node: Makefiles,  Next: Rules,  Prev: Introduction,  Up: Top

3 Writing Makefiles
*******************

The information that tells `make' how to recompile a system comes from
reading a data base called the "makefile".

* Menu:

* Makefile Contents::           What makefiles contain.
* Makefile Names::              How to name your makefile.
* Include::                     How one makefile can use another makefile.
* MAKEFILES Variable::          The environment can specify extra makefiles.
* MAKEFILE_LIST Variable::      Discover which makefiles have been read.
* Special Variables::           Other special variables.
* Remaking Makefiles::          How makefiles get remade.
* Overriding Makefiles::        How to override part of one makefile
                                  with another makefile.
* Reading Makefiles::           How makefiles are parsed.
* Secondary Expansion::         How and when secondary expansion is performed.


File: make.info,  Node: Makefile Contents,  Next: Makefile Names,  Prev: Makefiles,  Up: Makefiles

3.1 What Makefiles Contain
==========================

Makefiles contain five kinds of things: "explicit rules", "implicit
rules", "variable definitions", "directives", and "comments".  Rules,
variables, and directives are described at length in later chapters.

   * An "explicit rule" says when and how to remake one or more files,
     called the rule's "targets".  It lists the other files that the
     targets depend on, called the "prerequisites" of the target, and
     may also give commands to use to create or update the targets.
     *Note Writing Rules: Rules.

   * An "implicit rule" says when and how to remake a class of files
     based on their names.  It describes how a target may depend on a
     file with a name similar to the target and gives commands to
     create or update such a target.  *Note Using Implicit Rules:
     Implicit Rules.

   * A "variable definition" is a line that specifies a text string
     value for a variable that can be substituted into the text later.
     The simple makefile example shows a variable definition for
     `objects' as a list of all object files (*note Variables Make
     Makefiles Simpler: Variables Simplify.).

   * A "directive" is a command for `make' to do something special while
     reading the makefile.  These include:

        * Reading another makefile (*note Including Other Makefiles:
          Include.).

        * Deciding (based on the values of variables) whether to use or
          ignore a part of the makefile (*note Conditional Parts of
          Makefiles: Conditionals.).

        * Defining a variable from a verbatim string containing
          multiple lines (*note Defining Variables Verbatim: Defining.).

   * `#' in a line of a makefile starts a "comment".  It and the rest
     of the line are ignored, except that a trailing backslash not
     escaped by another backslash will continue the comment across
     multiple lines.  A line containing just a comment (with perhaps
     spaces before it) is effectively blank, and is ignored.  If you
     want a literal `#', escape it with a backslash (e.g., `\#').
     Comments may appear on any line in the makefile, although they are
     treated specially in certain situations.

     Within a command script (if the line begins with a TAB character)
     the entire line is passed to the shell, just as with any other
     line that begins with a TAB.  The shell decides how to interpret
     the text: whether or not this is a comment is up to the shell.

     Within a `define' directive, comments are not ignored during the
     definition of the variable, but rather kept intact in the value of
     the variable.  When the variable is expanded they will either be
     treated as `make' comments or as command script text, depending on
     the context in which the variable is evaluated.


File: make.info,  Node: Makefile Names,  Next: Include,  Prev: Makefile Contents,  Up: Makefiles

3.2 What Name to Give Your Makefile
===================================

By default, when `make' looks for the makefile, it tries the following
names, in order: `GNUmakefile', `makefile' and `Makefile'.  

   Normally you should call your makefile either `makefile' or
`Makefile'.  (We recommend `Makefile' because it appears prominently
near the beginning of a directory listing, right near other important
files such as `README'.)  The first name checked, `GNUmakefile', is not
recommended for most makefiles.  You should use this name if you have a
makefile that is specific to GNU `make', and will not be understood by
other versions of `make'.  Other `make' programs look for `makefile' and
`Makefile', but not `GNUmakefile'.

   If `make' finds none of these names, it does not use any makefile.
Then you must specify a goal with a command argument, and `make' will
attempt to figure out how to remake it using only its built-in implicit
rules.  *Note Using Implicit Rules: Implicit Rules.

   If you want to use a nonstandard name for your makefile, you can
specify the makefile name with the `-f' or `--file' option.  The
arguments `-f NAME' or `--file=NAME' tell `make' to read the file NAME
as the makefile.  If you use more than one `-f' or `--file' option, you
can specify several makefiles.  All the makefiles are effectively
concatenated in the order specified.  The default makefile names
`GNUmakefile', `makefile' and `Makefile' are not checked automatically
if you specify `-f' or `--file'.  


File: make.info,  Node: Include,  Next: MAKEFILES Variable,  Prev: Makefile Names,  Up: Makefiles

3.3 Including Other Makefiles
=============================

The `include' directive tells `make' to suspend reading the current
makefile and read one or more other makefiles before continuing.  The
directive is a line in the makefile that looks like this:

     include FILENAMES...

FILENAMES can contain shell file name patterns.  If FILENAMES is empty,
nothing is included and no error is printed.  

   Extra spaces are allowed and ignored at the beginning of the line,
but a tab is not allowed.  (If the line begins with a tab, it will be
considered a command line.)  Whitespace is required between `include'
and the file names, and between file names; extra whitespace is ignored
there and at the end of the directive.  A comment starting with `#' is
allowed at the end of the line.  If the file names contain any variable
or function references, they are expanded.  *Note How to Use Variables:
Using Variables.

   For example, if you have three `.mk' files, `a.mk', `b.mk', and
`c.mk', and `$(bar)' expands to `bish bash', then the following
expression

     include foo *.mk $(bar)

   is equivalent to

     include foo a.mk b.mk c.mk bish bash

   When `make' processes an `include' directive, it suspends reading of
the containing makefile and reads from each listed file in turn.  When
that is finished, `make' resumes reading the makefile in which the
directive appears.

   One occasion for using `include' directives is when several programs,
handled by individual makefiles in various directories, need to use a
common set of variable definitions (*note Setting Variables: Setting.)
or pattern rules (*note Defining and Redefining Pattern Rules: Pattern
Rules.).

   Another such occasion is when you want to generate prerequisites from
source files automatically; the prerequisites can be put in a file that
is included by the main makefile.  This practice is generally cleaner
than that of somehow appending the prerequisites to the end of the main
makefile as has been traditionally done with other versions of `make'.
*Note Automatic Prerequisites::.  

   If the specified name does not start with a slash, and the file is
not found in the current directory, several other directories are
searched.  First, any directories you have specified with the `-I' or
`--include-dir' option are searched (*note Summary of Options: Options
Summary.).  Then the following directories (if they exist) are
searched, in this order: `PREFIX/include' (normally `/usr/local/include'
(1)) `/usr/gnu/include', `/usr/local/include', `/usr/include'.

   If an included makefile cannot be found in any of these directories,
a warning message is generated, but it is not an immediately fatal
error; processing of the makefile containing the `include' continues.
Once it has finished reading makefiles, `make' will try to remake any
that are out of date or don't exist.  *Note How Makefiles Are Remade:
Remaking Makefiles.  Only after it has tried to find a way to remake a
makefile and failed, will `make' diagnose the missing makefile as a
fatal error.

   If you want `make' to simply ignore a makefile which does not exist
and cannot be remade, with no error message, use the `-include'
directive instead of `include', like this:

     -include FILENAMES...

   This acts like `include' in every way except that there is no error
(not even a warning) if any of the FILENAMES do not exist.  For
compatibility with some other `make' implementations, `sinclude' is
another name for `-include'.

   ---------- Footnotes ----------

   (1) GNU Make compiled for MS-DOS and MS-Windows behaves as if PREFIX
has been defined to be the root of the DJGPP tree hierarchy.


File: make.info,  Node: MAKEFILES Variable,  Next: MAKEFILE_LIST Variable,  Prev: Include,  Up: Makefiles

3.4 The Variable `MAKEFILES'
============================

If the environment variable `MAKEFILES' is defined, `make' considers
its value as a list of names (separated by whitespace) of additional
makefiles to be read before the others.  This works much like the
`include' directive: various directories are searched for those files
(*note Including Other Makefiles: Include.).  In addition, the default
goal is never taken from one of these makefiles and it is not an error
if the files listed in `MAKEFILES' are not found.

   The main use of `MAKEFILES' is in communication between recursive
invocations of `make' (*note Recursive Use of `make': Recursion.).  It
usually is not desirable to set the environment variable before a
top-level invocation of `make', because it is usually better not to
mess with a makefile from outside.  However, if you are running `make'
without a specific makefile, a makefile in `MAKEFILES' can do useful
things to help the built-in implicit rules work better, such as
defining search paths (*note Directory Search::).

   Some users are tempted to set `MAKEFILES' in the environment
automatically on login, and program makefiles to expect this to be done.
This is a very bad idea, because such makefiles will fail to work if
run by anyone else.  It is much better to write explicit `include'
directives in the makefiles.  *Note Including Other Makefiles: Include.


File: make.info,  Node: MAKEFILE_LIST Variable,  Next: Special Variables,  Prev: MAKEFILES Variable,  Up: Makefiles

3.5 The Variable `MAKEFILE_LIST'
================================

As `make' reads various makefiles, including any obtained from the
`MAKEFILES' variable, the command line, the default files, or from
`include' directives, their names will be automatically appended to the
`MAKEFILE_LIST' variable.  They are added right before `make' begins to
parse them.

   This means that if the first thing a makefile does is examine the
last word in this variable, it will be the name of the current makefile.
Once the current makefile has used `include', however, the last word
will be the just-included makefile.

   If a makefile named `Makefile' has this content:

     name1 := $(lastword $(MAKEFILE_LIST))

     include inc.mk

     name2 := $(lastword $(MAKEFILE_LIST))

     all:
             @echo name1 = $(name1)
             @echo name2 = $(name2)

then you would expect to see this output:

     name1 = Makefile
     name2 = inc.mk

   *Note Text Functions::, for more information on the `word' and
`words' functions used above.  *Note The Two Flavors of Variables:
Flavors, for more information on simply-expanded (`:=') variable
definitions.


File: make.info,  Node: Special Variables,  Next: Remaking Makefiles,  Prev: MAKEFILE_LIST Variable,  Up: Makefiles

3.6 Other Special Variables
===========================

GNU `make' also supports other special variables.  Unless otherwise
documented here, these values lose their special properties if they are
set by a makefile or on the command line.

`.DEFAULT_GOAL'
     Sets the default goal to be used if no targets were specified on
     the command line (*note Arguments to Specify the Goals: Goals.).
     The `.DEFAULT_GOAL' variable allows you to discover the current
     default goal, restart the default goal selection algorithm by
     clearing its value, or to explicitly set the default goal.  The
     following example illustrates these cases:

          # Query the default goal.
          ifeq ($(.DEFAULT_GOAL),)
            $(warning no default goal is set)
          endif

          .PHONY: foo
          foo: ; @echo $@

          $(warning default goal is $(.DEFAULT_GOAL))

          # Reset the default goal.
          .DEFAULT_GOAL :=

          .PHONY: bar
          bar: ; @echo $@

          $(warning default goal is $(.DEFAULT_GOAL))

          # Set our own.
          .DEFAULT_GOAL := foo

     This makefile prints:

          no default goal is set
          default goal is foo
          default goal is bar
          foo

     Note that assigning more than one target name to `.DEFAULT_GOAL' is
     illegal and will result in an error.

`MAKE_RESTARTS'
     This variable is set only if this instance of `make' has restarted
     (*note How Makefiles Are Remade: Remaking Makefiles.): it will
     contain the number of times this instance has restarted.  Note
     this is not the same as recursion (counted by the `MAKELEVEL'
     variable).  You should not set, modify, or export this variable.

`.VARIABLES'
     Expands to a list of the _names_ of all global variables defined
     so far.  This includes variables which have empty values, as well
     as built-in variables (*note Variables Used by Implicit Rules:
     Implicit Variables.), but does not include any variables which are
     only defined in a target-specific context.  Note that any value
     you assign to this variable will be ignored; it will always return
     its special value.

`.FEATURES'
     Expands to a list of special features supported by this version of
     `make'.  Possible values include:

    `archives'
          Supports `ar' (archive) files using special filename syntax.
          *Note Using `make' to Update Archive Files: Archives.

    `check-symlink'
          Supports the `-L' (`--check-symlink-times') flag.  *Note
          Summary of Options: Options Summary.

    `else-if'
          Supports "else if" non-nested conditionals.  *Note Syntax of
          Conditionals: Conditional Syntax.

    `jobserver'
          Supports "job server" enhanced parallel builds.  *Note
          Parallel Execution: Parallel.

    `second-expansion'
          Supports secondary expansion of prerequisite lists.

    `order-only'
          Supports order-only prerequisites.  *Note Types of
          Prerequisites: Prerequisite Types.

    `target-specific'
          Supports target-specific and pattern-specific variable
          assignments.  *Note Target-specific Variable Values:
          Target-specific.


`.INCLUDE_DIRS'
     Expands to a list of directories that `make' searches for included
     makefiles (*note Including Other Makefiles: Include.).



File: make.info,  Node: Remaking Makefiles,  Next: Overriding Makefiles,  Prev: Special Variables,  Up: Makefiles

3.7 How Makefiles Are Remade
============================

Sometimes makefiles can be remade from other files, such as RCS or SCCS
files.  If a makefile can be remade from other files, you probably want
`make' to get an up-to-date version of the makefile to read in.

   To this end, after reading in all makefiles, `make' will consider
each as a goal target and attempt to update it.  If a makefile has a
rule which says how to update it (found either in that very makefile or
in another one) or if an implicit rule applies to it (*note Using
Implicit Rules: Implicit Rules.), it will be updated if necessary.
After all makefiles have been checked, if any have actually been
changed, `make' starts with a clean slate and reads all the makefiles
over again.  (It will also attempt to update each of them over again,
but normally this will not change them again, since they are already up
to date.)

   If you know that one or more of your makefiles cannot be remade and
you want to keep `make' from performing an implicit rule search on
them, perhaps for efficiency reasons, you can use any normal method of
preventing implicit rule lookup to do so.  For example, you can write an
explicit rule with the makefile as the target, and an empty command
string (*note Using Empty Commands: Empty Commands.).

   If the makefiles specify a double-colon rule to remake a file with
commands but no prerequisites, that file will always be remade (*note
Double-Colon::).  In the case of makefiles, a makefile that has a
double-colon rule with commands but no prerequisites will be remade
every time `make' is run, and then again after `make' starts over and
reads the makefiles in again.  This would cause an infinite loop:
`make' would constantly remake the makefile, and never do anything
else.  So, to avoid this, `make' will *not* attempt to remake makefiles
which are specified as targets of a double-colon rule with commands but
no prerequisites.

   If you do not specify any makefiles to be read with `-f' or `--file'
options, `make' will try the default makefile names; *note What Name to
Give Your Makefile: Makefile Names.  Unlike makefiles explicitly
requested with `-f' or `--file' options, `make' is not certain that
these makefiles should exist.  However, if a default makefile does not
exist but can be created by running `make' rules, you probably want the
rules to be run so that the makefile can be used.

   Therefore, if none of the default makefiles exists, `make' will try
to make each of them in the same order in which they are searched for
(*note What Name to Give Your Makefile: Makefile Names.)  until it
succeeds in making one, or it runs out of names to try.  Note that it
is not an error if `make' cannot find or make any makefile; a makefile
is not always necessary.

   When you use the `-t' or `--touch' option (*note Instead of
Executing the Commands: Instead of Execution.), you would not want to
use an out-of-date makefile to decide which targets to touch.  So the
`-t' option has no effect on updating makefiles; they are really
updated even if `-t' is specified.  Likewise, `-q' (or `--question')
and `-n' (or `--just-print') do not prevent updating of makefiles,
because an out-of-date makefile would result in the wrong output for
other targets.  Thus, `make -f mfile -n foo' will update `mfile', read
it in, and then print the commands to update `foo' and its prerequisites
without running them.  The commands printed for `foo' will be those
specified in the updated contents of `mfile'.

   However, on occasion you might actually wish to prevent updating of
even the makefiles.  You can do this by specifying the makefiles as
goals in the command line as well as specifying them as makefiles.
When the makefile name is specified explicitly as a goal, the options
`-t' and so on do apply to them.

   Thus, `make -f mfile -n mfile foo' would read the makefile `mfile',
print the commands needed to update it without actually running them,
and then print the commands needed to update `foo' without running
them.  The commands for `foo' will be those specified by the existing
contents of `mfile'.


File: make.info,  Node: Overriding Makefiles,  Next: Reading Makefiles,  Prev: Remaking Makefiles,  Up: Makefiles

3.8 Overriding Part of Another Makefile
=======================================

Sometimes it is useful to have a makefile that is mostly just like
another makefile.  You can often use the `include' directive to include
one in the other, and add more targets or variable definitions.
However, if the two makefiles give different commands for the same
target, `make' will not let you just do this.  But there is another way.

   In the containing makefile (the one that wants to include the other),
you can use a match-anything pattern rule to say that to remake any
target that cannot be made from the information in the containing
makefile, `make' should look in another makefile.  *Note Pattern
Rules::, for more information on pattern rules.

   For example, if you have a makefile called `Makefile' that says how
to make the target `foo' (and other targets), you can write a makefile
called `GNUmakefile' that contains:

     foo:
             frobnicate > foo

     %: force
             @$(MAKE) -f Makefile $@
     force: ;

   If you say `make foo', `make' will find `GNUmakefile', read it, and
see that to make `foo', it needs to run the command `frobnicate > foo'.
If you say `make bar', `make' will find no way to make `bar' in
`GNUmakefile', so it will use the commands from the pattern rule: `make
-f Makefile bar'.  If `Makefile' provides a rule for updating `bar',
`make' will apply the rule.  And likewise for any other target that
`GNUmakefile' does not say how to make.

   The way this works is that the pattern rule has a pattern of just
`%', so it matches any target whatever.  The rule specifies a
prerequisite `force', to guarantee that the commands will be run even
if the target file already exists.  We give `force' target empty
commands to prevent `make' from searching for an implicit rule to build
it--otherwise it would apply the same match-anything rule to `force'
itself and create a prerequisite loop!


File: make.info,  Node: Reading Makefiles,  Next: Secondary Expansion,  Prev: Overriding Makefiles,  Up: Makefiles

3.9 How `make' Reads a Makefile
===============================

GNU `make' does its work in two distinct phases.  During the first
phase it reads all the makefiles, included makefiles, etc. and
internalizes all the variables and their values, implicit and explicit
rules, and constructs a dependency graph of all the targets and their
prerequisites.  During the second phase, `make' uses these internal
structures to determine what targets will need to be rebuilt and to
invoke the rules necessary to do so.

   It's important to understand this two-phase approach because it has a
direct impact on how variable and function expansion happens; this is
often a source of some confusion when writing makefiles.  Here we will
present a summary of the phases in which expansion happens for different
constructs within the makefile.  We say that expansion is "immediate"
if it happens during the first phase: in this case `make' will expand
any variables or functions in that section of a construct as the
makefile is parsed.  We say that expansion is "deferred" if expansion
is not performed immediately.  Expansion of deferred construct is not
performed until either the construct appears later in an immediate
context, or until the second phase.

   You may not be familiar with some of these constructs yet.  You can
reference this section as you become familiar with them, in later
chapters.

Variable Assignment
-------------------

Variable definitions are parsed as follows:

     IMMEDIATE = DEFERRED
     IMMEDIATE ?= DEFERRED
     IMMEDIATE := IMMEDIATE
     IMMEDIATE += DEFERRED or IMMEDIATE

     define IMMEDIATE
       DEFERRED
     endef

   For the append operator, `+=', the right-hand side is considered
immediate if the variable was previously set as a simple variable
(`:='), and deferred otherwise.

Conditional Statements
----------------------

All instances of conditional syntax are parsed immediately, in their
entirety; this includes the `ifdef', `ifeq', `ifndef', and `ifneq'
forms.  Of course this means that automatic variables cannot be used in
conditional statements, as automatic variables are not set until the
command script for that rule is invoked.  If you need to use automatic
variables in a conditional you _must_ use shell conditional syntax, in
your command script proper, for these tests, not `make' conditionals.

Rule Definition
---------------

A rule is always expanded the same way, regardless of the form:

     IMMEDIATE : IMMEDIATE ; DEFERRED
     	DEFERRED

   That is, the target and prerequisite sections are expanded
immediately, and the commands used to construct the target are always
deferred.  This general rule is true for explicit rules, pattern rules,
suffix rules, static pattern rules, and simple prerequisite definitions.


File: make.info,  Node: Secondary Expansion,  Prev: Reading Makefiles,  Up: Makefiles

3.10 Secondary Expansion
========================

In the previous section we learned that GNU `make' works in two
distinct phases: a read-in phase and a target-update phase (*note How
`make' Reads a Makefile: Reading Makefiles.).  GNU make also has the
ability to enable a _second expansion_ of the prerequisites (only) for
some or all targets defined in the makefile.  In order for this second
expansion to occur, the special target `.SECONDEXPANSION' must be
defined before the first prerequisite list that makes use of this
feature.

   If that special target is defined then in between the two phases
mentioned above, right at the end of the read-in phase, all the
prerequisites of the targets defined after the special target are
expanded a _second time_.  In most circumstances this secondary
expansion will have no effect, since all variable and function
references will have been expanded during the initial parsing of the
makefiles.  In order to take advantage of the secondary expansion phase
of the parser, then, it's necessary to _escape_ the variable or
function reference in the makefile.  In this case the first expansion
merely un-escapes the reference but doesn't expand it, and expansion is
left to the secondary expansion phase.  For example, consider this
makefile:

     .SECONDEXPANSION:
     ONEVAR = onefile
     TWOVAR = twofile
     myfile: $(ONEVAR) $$(TWOVAR)

   After the first expansion phase the prerequisites list of the
`myfile' target will be `onefile' and `$(TWOVAR)'; the first
(unescaped) variable reference to ONEVAR is expanded, while the second
(escaped) variable reference is simply unescaped, without being
recognized as a variable reference.  Now during the secondary expansion
the first word is expanded again but since it contains no variable or
function references it remains the static value `onefile', while the
second word is now a normal reference to the variable TWOVAR, which is
expanded to the value `twofile'.  The final result is that there are
two prerequisites, `onefile' and `twofile'.

   Obviously, this is not a very interesting case since the same result
could more easily have been achieved simply by having both variables
appear, unescaped, in the prerequisites list.  One difference becomes
apparent if the variables are reset; consider this example:

     .SECONDEXPANSION:
     AVAR = top
     onefile: $(AVAR)
     twofile: $$(AVAR)
     AVAR = bottom

   Here the prerequisite of `onefile' will be expanded immediately, and
resolve to the value `top', while the prerequisite of `twofile' will
not be full expanded until the secondary expansion and yield a value of
`bottom'.

   This is marginally more exciting, but the true power of this feature
only becomes apparent when you discover that secondary expansions
always take place within the scope of the automatic variables for that
target.  This means that you can use variables such as `$@', `$*', etc.
during the second expansion and they will have their expected values,
just as in the command script.  All you have to do is defer the
expansion by escaping the `$'.  Also, secondary expansion occurs for
both explicit and implicit (pattern) rules.  Knowing this, the possible
uses for this feature increase dramatically.  For example:

     .SECONDEXPANSION:
     main_OBJS := main.o try.o test.o
     lib_OBJS := lib.o api.o

     main lib: $$($$@_OBJS)

   Here, after the initial expansion the prerequisites of both the
`main' and `lib' targets will be `$($@_OBJS)'.  During the secondary
expansion, the `$@' variable is set to the name of the target and so
the expansion for the `main' target will yield `$(main_OBJS)', or
`main.o try.o test.o', while the secondary expansion for the `lib'
target will yield `$(lib_OBJS)', or `lib.o api.o'.

   You can also mix functions here, as long as they are properly
escaped:

     main_SRCS := main.c try.c test.c
     lib_SRCS := lib.c api.c

     .SECONDEXPANSION:
     main lib: $$(patsubst %.c,%.o,$$($$@_SRCS))

   This version allows users to specify source files rather than object
files, but gives the same resulting prerequisites list as the previous
example.

   Evaluation of automatic variables during the secondary expansion
phase, especially of the target name variable `$$@', behaves similarly
to evaluation within command scripts.  However, there are some subtle
differences and "corner cases" which come into play for the different
types of rule definitions that `make' understands.  The subtleties of
using the different automatic variables are described below.

Secondary Expansion of Explicit Rules
-------------------------------------

During the secondary expansion of explicit rules, `$$@' and `$$%'
evaluate, respectively, to the file name of the target and, when the
target is an archive member, the target member name.  The `$$<'
variable evaluates to the first prerequisite in the first rule for this
target.  `$$^' and `$$+' evaluate to the list of all prerequisites of
rules _that have already appeared_ for the same target (`$$+' with
repetitions and `$$^' without).  The following example will help
illustrate these behaviors:

     .SECONDEXPANSION:

     foo: foo.1 bar.1 $$< $$^ $$+    # line #1

     foo: foo.2 bar.2 $$< $$^ $$+    # line #2

     foo: foo.3 bar.3 $$< $$^ $$+    # line #3

   In the first prerequisite list, all three variables (`$$<', `$$^',
and `$$+') expand to the empty string.  In the second, they will have
values `foo.1', `foo.1 bar.1', and `foo.1 bar.1' respectively.  In the
third they will have values `foo.1', `foo.1 bar.1 foo.2 bar.2', and
`foo.1 bar.1 foo.2 bar.2' respectively.

   Rules undergo secondary expansion in makefile order, except that the
rule with the command script is always evaluated last.

   The variables `$$?' and `$$*' are not available and expand to the
empty string.

Secondary Expansion of Static Pattern Rules
-------------------------------------------

Rules for secondary expansion of static pattern rules are identical to
those for explicit rules, above, with one exception: for static pattern
rules the `$$*' variable is set to the pattern stem.  As with explicit
rules, `$$?' is not available and expands to the empty string.

Secondary Expansion of Implicit Rules
-------------------------------------

As `make' searches for an implicit rule, it substitutes the stem and
then performs secondary expansion for every rule with a matching target
pattern.  The value of the automatic variables is derived in the same
fashion as for static pattern rules.  As an example:

     .SECONDEXPANSION:

     foo: bar

     foo foz: fo%: bo%

     %oo: $$< $$^ $$+ $$*

   When the implicit rule is tried for target `foo', `$$<' expands to
`bar', `$$^' expands to `bar boo', `$$+' also expands to `bar boo', and
`$$*' expands to `f'.

   Note that the directory prefix (D), as described in *Note Implicit
Rule Search Algorithm: Implicit Rule Search, is appended (after
expansion) to all the patterns in the prerequisites list.  As an
example:

     .SECONDEXPANSION:

     /tmp/foo.o:

     %.o: $$(addsuffix /%.c,foo bar) foo.h

   The prerequisite list after the secondary expansion and directory
prefix reconstruction will be `/tmp/foo/foo.c /tmp/var/bar/foo.c
foo.h'.  If you are not interested in this reconstruction, you can use
`$$*' instead of `%' in the prerequisites list.


File: make.info,  Node: Rules,  Next: Commands,  Prev: Makefiles,  Up: Top

4 Writing Rules
***************

A "rule" appears in the makefile and says when and how to remake
certain files, called the rule's "targets" (most often only one per
rule).  It lists the other files that are the "prerequisites" of the
target, and "commands" to use to create or update the target.

   The order of rules is not significant, except for determining the
"default goal": the target for `make' to consider, if you do not
otherwise specify one.  The default goal is the target of the first
rule in the first makefile.  If the first rule has multiple targets,
only the first target is taken as the default.  There are two
exceptions: a target starting with a period is not a default unless it
contains one or more slashes, `/', as well; and, a target that defines
a pattern rule has no effect on the default goal.  (*Note Defining and
Redefining Pattern Rules: Pattern Rules.)

   Therefore, we usually write the makefile so that the first rule is
the one for compiling the entire program or all the programs described
by the makefile (often with a target called `all').  *Note Arguments to
Specify the Goals: Goals.

* Menu:

* Rule Example::                An example explained.
* Rule Syntax::                 General syntax explained.
* Prerequisite Types::          There are two types of prerequisites.
* Wildcards::                   Using wildcard characters such as `*'.
* Directory Search::            Searching other directories for source files.
* Phony Targets::               Using a target that is not a real file's name.
* Force Targets::               You can use a target without commands
                                  or prerequisites to mark other targets
                                  as phony.
* Empty Targets::               When only the date matters and the
                                  files are empty.
* Special Targets::             Targets with special built-in meanings.
* Multiple Targets::            When to make use of several targets in a rule.
* Multiple Rules::              How to use several rules with the same target.
* Static Pattern::              Static pattern rules apply to multiple targets
                                  and can vary the prerequisites according to
                                  the target name.
* Double-Colon::                How to use a special kind of rule to allow
                                  several independent rules for one target.
* Automatic Prerequisites::     How to automatically generate rules giving
                                  prerequisites from source files themselves.


File: make.info,  Node: Rule Example,  Next: Rule Syntax,  Prev: Rules,  Up: Rules

4.1 Rule Example
================

Here is an example of a rule:

     foo.o : foo.c defs.h       # module for twiddling the frobs
             cc -c -g foo.c

   Its target is `foo.o' and its prerequisites are `foo.c' and
`defs.h'.  It has one command, which is `cc -c -g foo.c'.  The command
line starts with a tab to identify it as a command.

   This rule says two things:

   * How to decide whether `foo.o' is out of date: it is out of date if
     it does not exist, or if either `foo.c' or `defs.h' is more recent
     than it.

   * How to update the file `foo.o': by running `cc' as stated.  The
     command does not explicitly mention `defs.h', but we presume that
     `foo.c' includes it, and that that is why `defs.h' was added to
     the prerequisites.


File: make.info,  Node: Rule Syntax,  Next: Prerequisite Types,  Prev: Rule Example,  Up: Rules

4.2 Rule Syntax
===============

In general, a rule looks like this:

     TARGETS : PREREQUISITES
             COMMAND
             ...

or like this:

     TARGETS : PREREQUISITES ; COMMAND
             COMMAND
             ...

   The TARGETS are file names, separated by spaces.  Wildcard
characters may be used (*note Using Wildcard Characters in File Names:
Wildcards.) and a name of the form `A(M)' represents member M in
archive file A (*note Archive Members as Targets: Archive Members.).
Usually there is only one target per rule, but occasionally there is a
reason to have more (*note Multiple Targets in a Rule: Multiple
Targets.).

   The COMMAND lines start with a tab character.  The first command may
appear on the line after the prerequisites, with a tab character, or may
appear on the same line, with a semicolon.  Either way, the effect is
the same.  There are other differences in the syntax of command lines.
*Note Writing the Commands in Rules: Commands.

   Because dollar signs are used to start `make' variable references,
if you really want a dollar sign in a target or prerequisite you must
write two of them, `$$' (*note How to Use Variables: Using Variables.).
If you have enabled secondary expansion (*note Secondary Expansion::)
and you want a literal dollar sign in the prerequisites lise, you must
actually write _four_ dollar signs (`$$$$').

   You may split a long line by inserting a backslash followed by a
newline, but this is not required, as `make' places no limit on the
length of a line in a makefile.

   A rule tells `make' two things: when the targets are out of date,
and how to update them when necessary.

   The criterion for being out of date is specified in terms of the
PREREQUISITES, which consist of file names separated by spaces.
(Wildcards and archive members (*note Archives::) are allowed here too.)
A target is out of date if it does not exist or if it is older than any
of the prerequisites (by comparison of last-modification times).  The
idea is that the contents of the target file are computed based on
information in the prerequisites, so if any of the prerequisites
changes, the contents of the existing target file are no longer
necessarily valid.

   How to update is specified by COMMANDS.  These are lines to be
executed by the shell (normally `sh'), but with some extra features
(*note Writing the Commands in Rules: Commands.).


File: make.info,  Node: Prerequisite Types,  Next: Wildcards,  Prev: Rule Syntax,  Up: Rules

4.3 Types of Prerequisites
==========================

There are actually two different types of prerequisites understood by
GNU `make': normal prerequisites such as described in the previous
section, and "order-only" prerequisites.  A normal prerequisite makes
two statements: first, it imposes an order of execution of build
commands: any commands necessary to build any of a target's
prerequisites will be fully executed before any commands necessary to
build the target.  Second, it imposes a dependency relationship: if any
prerequisite is newer than the target, then the target is considered
out-of-date and must be rebuilt.

   Normally, this is exactly what you want: if a target's prerequisite
is updated, then the target should also be updated.

   Occasionally, however, you have a situation where you want to impose
a specific ordering on the rules to be invoked _without_ forcing the
target to be updated if one of those rules is executed.  In that case,
you want to define "order-only" prerequisites.  Order-only
prerequisites can be specified by placing a pipe symbol (`|') in the
prerequisites list: any prerequisites to the left of the pipe symbol
are normal; any prerequisites to the right are order-only:

     TARGETS : NORMAL-PREREQUISITES | ORDER-ONLY-PREREQUISITES

   The normal prerequisites section may of course be empty.  Also, you
may still declare multiple lines of prerequisites for the same target:
they are appended appropriately.  Note that if you declare the same
file to be both a normal and an order-only prerequisite, the normal
prerequisite takes precedence (since they are a strict superset of the
behavior of an order-only prerequisite).


File: make.info,  Node: Wildcards,  Next: Directory Search,  Prev: Prerequisite Types,  Up: Rules

4.4 Using Wildcard Characters in File Names
===========================================

A single file name can specify many files using "wildcard characters".
The wildcard characters in `make' are `*', `?' and `[...]', the same as
in the Bourne shell.  For example, `*.c' specifies a list of all the
files (in the working directory) whose names end in `.c'.

   The character `~' at the beginning of a file name also has special
significance.  If alone, or followed by a slash, it represents your home
directory.  For example `~/bin' expands to `/home/you/bin'.  If the `~'
is followed by a word, the string represents the home directory of the
user named by that word.  For example `~john/bin' expands to
`/home/john/bin'.  On systems which don't have a home directory for
each user (such as MS-DOS or MS-Windows), this functionality can be
simulated by setting the environment variable HOME.

   Wildcard expansion is performed by `make' automatically in targets
and in prerequisites.  In commands the shell is responsible for
wildcard expansion.  In other contexts, wildcard expansion happens only
if you request it explicitly with the `wildcard' function.

   The special significance of a wildcard character can be turned off by
preceding it with a backslash.  Thus, `foo\*bar' would refer to a
specific file whose name consists of `foo', an asterisk, and `bar'.

* Menu:

* Wildcard Examples::           Several examples
* Wildcard Pitfall::            Problems to avoid.
* Wildcard Function::           How to cause wildcard expansion where
                                  it does not normally take place.


File: make.info,  Node: Wildcard Examples,  Next: Wildcard Pitfall,  Prev: Wildcards,  Up: Wildcards

4.4.1 Wildcard Examples
-----------------------

Wildcards can be used in the commands of a rule, where they are expanded
by the shell.  For example, here is a rule to delete all the object
files:

     clean:
             rm -f *.o

   Wildcards are also useful in the prerequisites of a rule.  With the
following rule in the makefile, `make print' will print all the `.c'
files that have changed since the last time you printed them:

     print: *.c
             lpr -p $?
             touch print

This rule uses `print' as an empty target file; see *Note Empty Target
Files to Record Events: Empty Targets.  (The automatic variable `$?' is
used to print only those files that have changed; see *Note Automatic
Variables::.)

   Wildcard expansion does not happen when you define a variable.
Thus, if you write this:

     objects = *.o

then the value of the variable `objects' is the actual string `*.o'.
However, if you use the value of `objects' in a target, prerequisite or
command, wildcard expansion will take place at that time.  To set
`objects' to the expansion, instead use:

     objects := $(wildcard *.o)

*Note Wildcard Function::.


File: make.info,  Node: Wildcard Pitfall,  Next: Wildcard Function,  Prev: Wildcard Examples,  Up: Wildcards

4.4.2 Pitfalls of Using Wildcards
---------------------------------

Now here is an example of a naive way of using wildcard expansion, that
does not do what you would intend.  Suppose you would like to say that
the executable file `foo' is made from all the object files in the
directory, and you write this:

     objects = *.o

     foo : $(objects)
             cc -o foo $(CFLAGS) $(objects)

The value of `objects' is the actual string `*.o'.  Wildcard expansion
happens in the rule for `foo', so that each _existing_ `.o' file
becomes a prerequisite of `foo' and will be recompiled if necessary.

   But what if you delete all the `.o' files?  When a wildcard matches
no files, it is left as it is, so then `foo' will depend on the
oddly-named file `*.o'.  Since no such file is likely to exist, `make'
will give you an error saying it cannot figure out how to make `*.o'.
This is not what you want!

   Actually it is possible to obtain the desired result with wildcard
expansion, but you need more sophisticated techniques, including the
`wildcard' function and string substitution.  *Note The Function
`wildcard': Wildcard Function.

   Microsoft operating systems (MS-DOS and MS-Windows) use backslashes
to separate directories in pathnames, like so:

       c:\foo\bar\baz.c

   This is equivalent to the Unix-style `c:/foo/bar/baz.c' (the `c:'
part is the so-called drive letter).  When `make' runs on these
systems, it supports backslashes as well as the Unix-style forward
slashes in pathnames.  However, this support does _not_ include the
wildcard expansion, where backslash is a quote character.  Therefore,
you _must_ use Unix-style slashes in these cases.


File: make.info,  Node: Wildcard Function,  Prev: Wildcard Pitfall,  Up: Wildcards

4.4.3 The Function `wildcard'
-----------------------------

Wildcard expansion happens automatically in rules.  But wildcard
expansion does not normally take place when a variable is set, or
inside the arguments of a function.  If you want to do wildcard
expansion in such places, you need to use the `wildcard' function, like
this:

     $(wildcard PATTERN...)

This string, used anywhere in a makefile, is replaced by a
space-separated list of names of existing files that match one of the
given file name patterns.  If no existing file name matches a pattern,
then that pattern is omitted from the output of the `wildcard'
function.  Note that this is different from how unmatched wildcards
behave in rules, where they are used verbatim rather than ignored
(*note Wildcard Pitfall::).

   One use of the `wildcard' function is to get a list of all the C
source files in a directory, like this:

     $(wildcard *.c)

   We can change the list of C source files into a list of object files
by replacing the `.c' suffix with `.o' in the result, like this:

     $(patsubst %.c,%.o,$(wildcard *.c))

(Here we have used another function, `patsubst'.  *Note Functions for
String Substitution and Analysis: Text Functions.)

   Thus, a makefile to compile all C source files in the directory and
then link them together could be written as follows:

     objects := $(patsubst %.c,%.o,$(wildcard *.c))

     foo : $(objects)
             cc -o foo $(objects)

(This takes advantage of the implicit rule for compiling C programs, so
there is no need to write explicit rules for compiling the files.
*Note The Two Flavors of Variables: Flavors, for an explanation of
`:=', which is a variant of `='.)


File: make.info,  Node: Directory Search,  Next: Phony Targets,  Prev: Wildcards,  Up: Rules

4.5 Searching Directories for Prerequisites
===========================================

For large systems, it is often desirable to put sources in a separate
directory from the binaries.  The "directory search" features of `make'
facilitate this by searching several directories automatically to find
a prerequisite.  When you redistribute the files among directories, you
do not need to change the individual rules, just the search paths.

* Menu:

* General Search::              Specifying a search path that applies
                                  to every prerequisite.
* Selective Search::            Specifying a search path
                                  for a specified class of names.
* Search Algorithm::            When and how search paths are applied.
* Commands/Search::             How to write shell commands that work together
                                  with search paths.
* Implicit/Search::             How search paths affect implicit rules.
* Libraries/Search::            Directory search for link libraries.


File: make.info,  Node: General Search,  Next: Selective Search,  Prev: Directory Search,  Up: Directory Search

4.5.1 `VPATH': Search Path for All Prerequisites
------------------------------------------------

The value of the `make' variable `VPATH' specifies a list of
directories that `make' should search.  Most often, the directories are
expected to contain prerequisite files that are not in the current
directory; however, `make' uses `VPATH' as a search list for both
prerequisites and targets of rules.

   Thus, if a file that is listed as a target or prerequisite does not
exist in the current directory, `make' searches the directories listed
in `VPATH' for a file with that name.  If a file is found in one of
them, that file may become the prerequisite (see below).  Rules may then
specify the names of files in the prerequisite list as if they all
existed in the current directory.  *Note Writing Shell Commands with
Directory Search: Commands/Search.

   In the `VPATH' variable, directory names are separated by colons or
blanks.  The order in which directories are listed is the order followed
by `make' in its search.  (On MS-DOS and MS-Windows, semi-colons are
used as separators of directory names in `VPATH', since the colon can
be used in the pathname itself, after the drive letter.)

   For example,

     VPATH = src:../headers

specifies a path containing two directories, `src' and `../headers',
which `make' searches in that order.

   With this value of `VPATH', the following rule,

     foo.o : foo.c

is interpreted as if it were written like this:

     foo.o : src/foo.c

assuming the file `foo.c' does not exist in the current directory but
is found in the directory `src'.


File: make.info,  Node: Selective Search,  Next: Search Algorithm,  Prev: General Search,  Up: Directory Search

4.5.2 The `vpath' Directive
---------------------------

Similar to the `VPATH' variable, but more selective, is the `vpath'
directive (note lower case), which allows you to specify a search path
for a particular class of file names: those that match a particular
pattern.  Thus you can supply certain search directories for one class
of file names and other directories (or none) for other file names.

   There are three forms of the `vpath' directive:

`vpath PATTERN DIRECTORIES'
     Specify the search path DIRECTORIES for file names that match
     PATTERN.

     The search path, DIRECTORIES, is a list of directories to be
     searched, separated by colons (semi-colons on MS-DOS and
     MS-Windows) or blanks, just like the search path used in the
     `VPATH' variable.

`vpath PATTERN'
     Clear out the search path associated with PATTERN.

`vpath'
     Clear all search paths previously specified with `vpath'
     directives.

   A `vpath' pattern is a string containing a `%' character.  The
string must match the file name of a prerequisite that is being searched
for, the `%' character matching any sequence of zero or more characters
(as in pattern rules; *note Defining and Redefining Pattern Rules:
Pattern Rules.).  For example, `%.h' matches files that end in `.h'.
(If there is no `%', the pattern must match the prerequisite exactly,
which is not useful very often.)

   `%' characters in a `vpath' directive's pattern can be quoted with
preceding backslashes (`\').  Backslashes that would otherwise quote
`%' characters can be quoted with more backslashes.  Backslashes that
quote `%' characters or other backslashes are removed from the pattern
before it is compared to file names.  Backslashes that are not in
danger of quoting `%' characters go unmolested.

   When a prerequisite fails to exist in the current directory, if the
PATTERN in a `vpath' directive matches the name of the prerequisite
file, then the DIRECTORIES in that directive are searched just like
(and before) the directories in the `VPATH' variable.

   For example,

     vpath %.h ../headers

tells `make' to look for any prerequisite whos